[
    {
        "feature_id": "VOLATILITY_ATR_V1",
        "name": "Average True Range",
        "category": "VOLATILITY",
        "description": "Standard ATR and Normalized ATR.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass ATRIndicator:\n    def compute(self, df: pd.DataFrame, window: int = 14) -> pd.DataFrame:\n        atr = ta.volatility.AverageTrueRange(df[\"high\"], df[\"low\"], df[\"close\"], window=window)\n        vals = atr.average_true_range()\n        atr_norm = vals / df[\"close\"] * 100\n        return pd.DataFrame({f\"ATR_{window}\": vals, f\"ATR_norm_{window}\": atr_norm}, index=df.index)\n",
        "handler_func": "ATRIndicator",
        "params": [
            {
                "name": "window",
                "param_type": "int",
                "min": 5,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 14
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLATILITY_BB_V1",
        "name": "Bollinger Bands",
        "category": "VOLATILITY",
        "description": "Bollinger Bands Upper/Lower/Width.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass BBIndicator:\n    def compute(self, df: pd.DataFrame, window: int = 20, std_dev: float = 2.0) -> pd.DataFrame:\n        bb = ta.volatility.BollingerBands(df[\"close\"], window=window, window_dev=std_dev)\n        return pd.DataFrame({\n            f\"BB_upper_{window}\": bb.bollinger_hband(),\n            f\"BB_lower_{window}\": bb.bollinger_lband(),\n            f\"BB_width_{window}\": bb.bollinger_wband()\n        }, index=df.index)\n",
        "handler_func": "BBIndicator",
        "params": [
            {
                "name": "window",
                "param_type": "int",
                "min": 10,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 20
            },
            {
                "name": "std_dev",
                "param_type": "float",
                "min": 1.5,
                "max": 3.0,
                "step": 0.1,
                "choices": null,
                "default": 2.0
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLATILITY_KC_V1",
        "name": "Keltner Channels",
        "category": "VOLATILITY",
        "description": "Keltner Channels (EMA +/- scalar*ATR).",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass KCIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 20, scalar: float = 2.0) -> pd.DataFrame:\n        # Note: ta library KeltnerChannel uses EMA for central line, and ATR for bands\n        kc = ta.volatility.KeltnerChannel(df[\"high\"], df[\"low\"], df[\"close\"], window=length, window_atr=length)\n        # Using separate multipliers isn't directly supported in standard KeltnerChannel init in some versions, \n        # but ta's default uses 2.0? Actually ta 0.10+ takes no scalar? \n        # Let's adjust manually if needed, but for now we assume standard implementation.\n        # Wait, ta.volatility.KeltnerChannel doesn't let us easily set multiplier in some versions.\n        # Let's implement manually to be safe and support 'scalar'.\n        \n        # Central = EMA(length)\n        ema = ta.trend.EMAIndicator(df[\"close\"], window=length).ema_indicator()\n        atr = ta.volatility.AverageTrueRange(df[\"high\"], df[\"low\"], df[\"close\"], window=length).average_true_range()\n        \n        upper = ema + (scalar * atr)\n        lower = ema - (scalar * atr)\n        \n        return pd.DataFrame({\n            f\"KC_upper_{length}_{scalar}\": upper,\n            f\"KC_lower_{length}_{scalar}\": lower\n        }, index=df.index)\n",
        "handler_func": "KCIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 10,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 20
            },
            {
                "name": "scalar",
                "param_type": "float",
                "min": 1.0,
                "max": 3.0,
                "step": 0.1,
                "choices": null,
                "default": 2.0
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLATILITY_DONCHIAN_V1",
        "name": "Donchian Channels",
        "category": "VOLATILITY",
        "description": "Donchian Channels.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass DonchianIndicator:\n    def compute(self, df: pd.DataFrame, lower_length: int = 20, upper_length: int = 20) -> pd.DataFrame:\n        # ta library DonchianChannel uses single window\n        # We will iterate or use max window if different, but let's just use one window for simplicity in wrapper\n        # if user passes different lengths, we default to max (or implement manually)\n        window = max(lower_length, upper_length)\n        dc = ta.volatility.DonchianChannel(df[\"high\"], df[\"low\"], df[\"close\"], window=window)\n        return pd.DataFrame({\n            f\"DC_high_{window}\": dc.donchian_channel_hband(),\n            f\"DC_low_{window}\": dc.donchian_channel_lband()\n        }, index=df.index)\n",
        "handler_func": "DonchianIndicator",
        "params": [
            {
                "name": "lower_length",
                "param_type": "int",
                "min": 10,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 20
            },
            {
                "name": "upper_length",
                "param_type": "int",
                "min": 10,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 20
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "MOMENTUM_RSI_V1",
        "name": "Relative Strength Index",
        "category": "MOMENTUM",
        "description": "RSI with Overbought/Oversold signals.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass RSIIndicator:\n    def compute(self, df: pd.DataFrame, window: int = 14, threshold_low: int = 30, threshold_high: int = 70) -> pd.DataFrame:\n        rsi = ta.momentum.RSIIndicator(df[\"close\"], window=window).rsi()\n        return pd.DataFrame({\n            f\"RSI_{window}\": rsi,\n            f\"RSI_signal_{window}\": rsi.apply(lambda x: 1 if x < threshold_low else (-1 if x > threshold_high else 0))\n        }, index=df.index)\n",
        "handler_func": "RSIIndicator",
        "params": [
            {
                "name": "window",
                "param_type": "int",
                "min": 5,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 14
            },
            {
                "name": "threshold_low",
                "param_type": "int",
                "min": 20,
                "max": 40,
                "step": null,
                "choices": null,
                "default": 30
            },
            {
                "name": "threshold_high",
                "param_type": "int",
                "min": 60,
                "max": 80,
                "step": null,
                "choices": null,
                "default": 70
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "MOMENTUM_MACD_V1",
        "name": "MACD",
        "category": "MOMENTUM",
        "description": "MACD Line, Signal, Diff.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass MACDIndicator:\n    def compute(self, df: pd.DataFrame, fast: int = 12, slow: int = 26, signal: int = 9) -> pd.DataFrame:\n        macd = ta.trend.MACD(df[\"close\"], window_slow=slow, window_fast=fast, window_sign=signal)\n        return pd.DataFrame({\n            f\"MACD_line_{fast}_{slow}\": macd.macd(),\n            f\"MACD_diff_{fast}_{slow}\": macd.macd_diff(),\n            f\"MACD_sig_{fast}_{slow}\": macd.macd_signal()\n        }, index=df.index)\n",
        "handler_func": "MACDIndicator",
        "params": [
            {
                "name": "fast",
                "param_type": "int",
                "min": 5,
                "max": 20,
                "step": null,
                "choices": null,
                "default": 12
            },
            {
                "name": "slow",
                "param_type": "int",
                "min": 21,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 26
            },
            {
                "name": "signal",
                "param_type": "int",
                "min": 5,
                "max": 15,
                "step": null,
                "choices": null,
                "default": 9
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "MEANREV_STOCH_V1",
        "name": "Stochastic Oscillator",
        "category": "MEAN_REVERSION",
        "description": "Stochastic Oscillator K and D.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass StochIndicator:\n    def compute(self, df: pd.DataFrame, window: int = 14, smooth_k: int = 3, smooth_d: int = 3) -> pd.DataFrame:\n        stoch = ta.momentum.StochasticOscillator(df[\"high\"], df[\"low\"], df[\"close\"], window=window, smooth_window=smooth_k)\n        return pd.DataFrame({\n            f\"STOCH_k_{window}\": stoch.stoch(),\n            f\"STOCH_d_{window}\": stoch.stoch_signal()\n        }, index=df.index)\n",
        "handler_func": "StochIndicator",
        "params": [
            {
                "name": "window",
                "param_type": "int",
                "min": 5,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 14
            },
            {
                "name": "smooth_k",
                "param_type": "int",
                "min": 1,
                "max": 10,
                "step": null,
                "choices": null,
                "default": 3
            },
            {
                "name": "smooth_d",
                "param_type": "int",
                "min": 1,
                "max": 10,
                "step": null,
                "choices": null,
                "default": 3
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "MOMENTUM_CCI_V1",
        "name": "Commodity Channel Index",
        "category": "MOMENTUM",
        "description": "CCI.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass CCIIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 20, c: float = 0.015) -> pd.DataFrame:\n        # Fixed: ta.trend.CCIIndicator for updated library versions\n        vals = ta.trend.CCIIndicator(df[\"high\"], df[\"low\"], df[\"close\"], window=length, constant=c).cci()\n        return pd.DataFrame({f\"CCI_{length}\": vals}, index=df.index)\n",
        "handler_func": "CCIIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 10,
                "max": 100,
                "step": null,
                "choices": null,
                "default": 20
            },
            {
                "name": "c",
                "param_type": "float",
                "min": 0.01,
                "max": 0.05,
                "step": null,
                "choices": null,
                "default": 0.015
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "MOMENTUM_ROC_V1",
        "name": "Rate of Change",
        "category": "MOMENTUM",
        "description": "Rate of Change (%).",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass ROCIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 10) -> pd.DataFrame:\n        vals = ta.momentum.ROCIndicator(df[\"close\"], window=length).roc()\n        return pd.DataFrame({f\"ROC_{length}\": vals}, index=df.index)\n",
        "handler_func": "ROCIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 1,
                "max": 30,
                "step": null,
                "choices": null,
                "default": 10
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "MOMENTUM_WILLR_V1",
        "name": "Williams %R",
        "category": "MOMENTUM",
        "description": "Williams %R.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass WillRIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 14) -> pd.DataFrame:\n        vals = ta.momentum.WilliamsRIndicator(df[\"high\"], df[\"low\"], df[\"close\"], lbp=length).williams_r()\n        return pd.DataFrame({f\"WILLR_{length}\": vals}, index=df.index)\n",
        "handler_func": "WillRIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 5,
                "max": 30,
                "step": null,
                "choices": null,
                "default": 14
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "MOMENTUM_MOM_V1",
        "name": "Momentum",
        "category": "MOMENTUM",
        "description": "Simple Price Momentum.",
        "code_snippet": "\nimport pandas as pd\n\nclass MomIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 10) -> pd.DataFrame:\n        # Simple Momentum: Price - Price(n)\n        vals = df[\"close\"].diff(periods=length)\n        return pd.DataFrame({f\"MOM_{length}\": vals}, index=df.index)\n",
        "handler_func": "MomIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 1,
                "max": 30,
                "step": null,
                "choices": null,
                "default": 10
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "MOMENTUM_CMO_V1",
        "name": "Chande Momentum Oscillator",
        "category": "MOMENTUM",
        "description": "CMO Derived from RSI.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass CMOIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 14) -> pd.DataFrame:\n        # CMO = (RSI - 50) * 2\n        rsi = ta.momentum.RSIIndicator(df[\"close\"], window=length).rsi()\n        cmo = (rsi - 50) * 2\n        return pd.DataFrame({f\"CMO_{length}\": cmo}, index=df.index)\n",
        "handler_func": "CMOIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 5,
                "max": 30,
                "step": null,
                "choices": null,
                "default": 14
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "TREND_MACROSS_V1",
        "name": "Moving Average Crossover",
        "category": "TREND",
        "description": "MA Cross Spread.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass MACrossIndicator:\n    def compute(self, df: pd.DataFrame, fast: int = 20, slow: int = 60, ma_type: str = \"sma\") -> pd.DataFrame:\n        if ma_type == \"ema\":\n            ma_f = ta.trend.EMAIndicator(df[\"close\"], window=fast).ema_indicator()\n            ma_s = ta.trend.EMAIndicator(df[\"close\"], window=slow).ema_indicator()\n        else:\n            ma_f = ta.trend.SMAIndicator(df[\"close\"], window=fast).sma_indicator()\n            ma_s = ta.trend.SMAIndicator(df[\"close\"], window=slow).sma_indicator()\n            \n        cross_spread = (ma_f - ma_s) / (ma_s + 1e-6)\n        return pd.DataFrame({f\"MA_spread_{fast}_{slow}\": cross_spread}, index=df.index)\n",
        "handler_func": "MACrossIndicator",
        "params": [
            {
                "name": "fast",
                "param_type": "int",
                "min": 5,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 20
            },
            {
                "name": "slow",
                "param_type": "int",
                "min": 20,
                "max": 200,
                "step": null,
                "choices": null,
                "default": 60
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "TREND_ADX_V1",
        "name": "Average Directional Index",
        "category": "TREND",
        "description": "ADX Strength and Direction.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass ADXIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 14) -> pd.DataFrame:\n        # Note: ta ADX takes window param\n        adx = ta.trend.ADXIndicator(df[\"high\"], df[\"low\"], df[\"close\"], window=length)\n        return pd.DataFrame({\n            f\"ADX_{length}\": adx.adx(),\n            f\"ADX_pos_{length}\": adx.adx_pos(),\n            f\"ADX_neg_{length}\": adx.adx_neg()\n        }, index=df.index)\n",
        "handler_func": "ADXIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 5,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 14
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "TREND_TRIX_V1",
        "name": "Triple Exponential Average",
        "category": "TREND",
        "description": "TRIX Oscillator.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass TRIXIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 30) -> pd.DataFrame:\n        t = ta.trend.TRIXIndicator(df[\"close\"], window=length)\n        return pd.DataFrame({f\"TRIX_{length}\": t.trix()}, index=df.index)\n",
        "handler_func": "TRIXIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 10,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 30
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "TREND_ICHIMOKU_V1",
        "name": "Ichimoku Cloud",
        "category": "TREND",
        "description": "Ichimoku Lines.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass IchimokuIndicator:\n    def compute(self, df: pd.DataFrame, tenkan: int = 9, kijun: int = 26, senkou: int = 52) -> pd.DataFrame:\n        ichi = ta.trend.IchimokuIndicator(df[\"high\"], df[\"low\"], window1=tenkan, window2=kijun, window3=senkou)\n        return pd.DataFrame({\n            f\"ICHI_conv_{tenkan}\": ichi.ichimoku_conversion_line(),\n            f\"ICHI_base_{kijun}\": ichi.ichimoku_base_line(),\n            f\"ICHI_spanA_{senkou}\": ichi.ichimoku_a(),\n            f\"ICHI_spanB_{senkou}\": ichi.ichimoku_b()\n        }, index=df.index)\n",
        "handler_func": "IchimokuIndicator",
        "params": [
            {
                "name": "tenkan",
                "param_type": "int",
                "min": 5,
                "max": 20,
                "step": null,
                "choices": null,
                "default": 9
            },
            {
                "name": "kijun",
                "param_type": "int",
                "min": 20,
                "max": 40,
                "step": null,
                "choices": null,
                "default": 26
            },
            {
                "name": "senkou",
                "param_type": "int",
                "min": 40,
                "max": 60,
                "step": null,
                "choices": null,
                "default": 52
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "TREND_SUPER_V1",
        "name": "Supertrend",
        "category": "TREND",
        "description": "Supertrend Direction and Bands.",
        "code_snippet": "\nimport pandas as pd\nimport numpy as np\nimport ta\n\nclass SupertrendIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 7, multiplier: float = 3.0) -> pd.DataFrame:\n        # Manual Supertrend Implementation\n        high = df['high']\n        low = df['low']\n        close = df['close']\n        \n        # Calculate ATR\n        atr = ta.volatility.AverageTrueRange(high, low, close, window=length).average_true_range()\n        \n        # Calculate Basic Bands\n        hl2 = (high + low) / 2\n        basic_upper = hl2 + (multiplier * atr)\n        basic_lower = hl2 - (multiplier * atr)\n        \n        # Final Bands\n        final_upper = pd.Series(0.0, index=df.index)\n        final_lower = pd.Series(0.0, index=df.index)\n        trend = pd.Series(1, index=df.index) # 1 for Bull, -1 for Bear\n        \n        # Iterative calculation (Slow in Python, but needed for recursive logic)\n        # For simplicity and perf, we can use shift vectorized approach for bands, \n        # but trend switch logic is recursive.\n        \n        # Using simple Numba-like logic loop\n        bu = basic_upper.values\n        bl = basic_lower.values\n        cl = close.values\n        \n        fu = np.zeros(len(cl))\n        fl = np.zeros(len(cl))\n        tr = np.zeros(len(cl))\n        \n        # Init\n        fu[0] = bu[0]\n        fl[0] = bl[0]\n        tr[0] = 1\n        \n        for i in range(1, len(cl)):\n            # Final Upper\n            if (bu[i] < fu[i-1]) or (cl[i-1] > fu[i-1]):\n                fu[i] = bu[i]\n            else:\n                fu[i] = fu[i-1]\n                \n            # Final Lower\n            if (bl[i] > fl[i-1]) or (cl[i-1] < fl[i-1]):\n                fl[i] = bl[i]\n            else:\n                fl[i] = fl[i-1]\n                \n            # Trend\n            # If prev was bull (1)\n            if tr[i-1] == 1:\n                if cl[i] <= fl[i]:\n                    tr[i] = -1\n                else:\n                    tr[i] = 1\n            else: # Prev was bear (-1)\n                if cl[i] >= fu[i]:\n                    tr[i] = 1\n                else:\n                    tr[i] = -1\n                    \n        return pd.DataFrame({\n            f\"SUP_trend_{length}_{multiplier}\": tr,\n            f\"SUP_upper_{length}_{multiplier}\": fu,\n            f\"SUP_lower_{length}_{multiplier}\": fl\n        }, index=df.index)\n",
        "handler_func": "SupertrendIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 5,
                "max": 20,
                "step": null,
                "choices": null,
                "default": 7
            },
            {
                "name": "multiplier",
                "param_type": "float",
                "min": 1.0,
                "max": 4.0,
                "step": 0.5,
                "choices": null,
                "default": 3.0
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLUME_OBV_V1",
        "name": "On-Balance Volume",
        "category": "VOLUME",
        "description": "On-Balance Volume.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass OBVIndicator:\n    def compute(self, df: pd.DataFrame) -> pd.DataFrame:\n        obv = ta.volume.OnBalanceVolumeIndicator(df[\"close\"], df[\"volume\"]).on_balance_volume()\n        return pd.DataFrame({\"OBV\": obv}, index=df.index)\n",
        "handler_func": "OBVIndicator",
        "params": [],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLUME_MFI_V1",
        "name": "Money Flow Index",
        "category": "VOLUME",
        "description": "Money Flow Index.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass MFIIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 14) -> pd.DataFrame:\n        mfi = ta.volume.MFIIndicator(df[\"high\"], df[\"low\"], df[\"close\"], df[\"volume\"], window=length).money_flow_index()\n        return pd.DataFrame({f\"MFI_{length}\": mfi}, index=df.index)\n",
        "handler_func": "MFIIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 5,
                "max": 30,
                "step": null,
                "choices": null,
                "default": 14
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLUME_CMF_V1",
        "name": "Chaikin Money Flow",
        "category": "VOLUME",
        "description": "Chaikin Money Flow.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass CMFIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 20) -> pd.DataFrame:\n        cmf = ta.volume.ChaikinMoneyFlowIndicator(df[\"high\"], df[\"low\"], df[\"close\"], df[\"volume\"], window=length).chaikin_money_flow()\n        return pd.DataFrame({f\"CMF_{length}\": cmf}, index=df.index)\n",
        "handler_func": "CMFIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 10,
                "max": 30,
                "step": null,
                "choices": null,
                "default": 20
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLUME_EOM_V1",
        "name": "Ease of Movement",
        "category": "VOLUME",
        "description": "Ease of Movement.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass EOMIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 14) -> pd.DataFrame:\n        eom = ta.volume.EaseOfMovementIndicator(df[\"high\"], df[\"low\"], df[\"volume\"], window=length).ease_of_movement()\n        return pd.DataFrame({f\"EOM_{length}\": eom}, index=df.index)\n",
        "handler_func": "EOMIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 5,
                "max": 30,
                "step": null,
                "choices": null,
                "default": 14
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "TREND_PSAR_V1",
        "name": "Parabolic SAR",
        "category": "TREND",
        "description": "Parabolic Stop and Reverse.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass PSARIndicator:\n    def compute(self, df: pd.DataFrame, step: float = 0.02, max_step: float = 0.2) -> pd.DataFrame:\n        psar = ta.trend.PSARIndicator(df[\"high\"], df[\"low\"], df[\"close\"], step=step, max_step=max_step)\n        return pd.DataFrame({\n            \"PSAR\": psar.psar(),\n            \"PSAR_up\": psar.psar_up(),\n            \"PSAR_down\": psar.psar_down()\n        }, index=df.index)\n",
        "handler_func": "PSARIndicator",
        "params": [
            {
                "name": "step",
                "param_type": "float",
                "min": 0.01,
                "max": 0.05,
                "step": 0.01,
                "choices": null,
                "default": 0.02
            },
            {
                "name": "max_step",
                "param_type": "float",
                "min": 0.1,
                "max": 0.5,
                "step": 0.1,
                "choices": null,
                "default": 0.2
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "TREND_AROON_V1",
        "name": "Aroon",
        "category": "TREND",
        "description": "Aroon Up/Down/Indicator.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass AroonIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 25) -> pd.DataFrame:\n        aroon = ta.trend.AroonIndicator(df[\"close\"], window=length)\n        return pd.DataFrame({\n            f\"AROON_up_{length}\": aroon.aroon_up(),\n            f\"AROON_down_{length}\": aroon.aroon_down(),\n            f\"AROON_ind_{length}\": aroon.aroon_indicator()\n        }, index=df.index)\n",
        "handler_func": "AroonIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 10,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 25
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "MOMENTUM_AO_V1",
        "name": "Awesome Oscillator",
        "category": "MOMENTUM",
        "description": "Awesome Oscillator.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass AOIndicator:\n    def compute(self, df: pd.DataFrame, fast: int = 5, slow: int = 34) -> pd.DataFrame:\n        ao = ta.momentum.AwesomeOscillatorIndicator(df[\"high\"], df[\"low\"], window1=fast, window2=slow)\n        return pd.DataFrame({f\"AO_{fast}_{slow}\": ao.awesome_oscillator()}, index=df.index)\n",
        "handler_func": "AOIndicator",
        "params": [
            {
                "name": "fast",
                "param_type": "int",
                "min": 2,
                "max": 10,
                "step": null,
                "choices": null,
                "default": 5
            },
            {
                "name": "slow",
                "param_type": "int",
                "min": 20,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 34
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "MOMENTUM_TSI_V1",
        "name": "True Strength Index",
        "category": "MOMENTUM",
        "description": "True Strength Index.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass TSIIndicator:\n    def compute(self, df: pd.DataFrame, high_len: int = 25, low_len: int = 13) -> pd.DataFrame:\n        tsi = ta.momentum.TSIIndicator(df[\"close\"], window_slow=high_len, window_fast=low_len)\n        return pd.DataFrame({f\"TSI_{high_len}_{low_len}\": tsi.tsi()}, index=df.index)\n",
        "handler_func": "TSIIndicator",
        "params": [
            {
                "name": "high_len",
                "param_type": "int",
                "min": 15,
                "max": 40,
                "step": null,
                "choices": null,
                "default": 25
            },
            {
                "name": "low_len",
                "param_type": "int",
                "min": 5,
                "max": 20,
                "step": null,
                "choices": null,
                "default": 13
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "MOMENTUM_KST_V1",
        "name": "Know Sure Thing",
        "category": "MOMENTUM",
        "description": "KST Oscillator.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass KSTIndicator:\n    def compute(self, df: pd.DataFrame, r1: int = 10, r2: int = 15, r3: int = 20, r4: int = 30) -> pd.DataFrame:\n        kst = ta.trend.KSTIndicator(df[\"close\"], roc1=r1, roc2=r2, roc3=r3, roc4=r4)\n        return pd.DataFrame({\n            \"KST\": kst.kst(),\n            \"KST_sig\": kst.kst_sig()\n        }, index=df.index)\n",
        "handler_func": "KSTIndicator",
        "params": [
            {
                "name": "r1",
                "param_type": "int",
                "min": 5,
                "max": 15,
                "step": null,
                "choices": null,
                "default": 10
            },
            {
                "name": "r2",
                "param_type": "int",
                "min": 10,
                "max": 20,
                "step": null,
                "choices": null,
                "default": 15
            },
            {
                "name": "r3",
                "param_type": "int",
                "min": 15,
                "max": 25,
                "step": null,
                "choices": null,
                "default": 20
            },
            {
                "name": "r4",
                "param_type": "int",
                "min": 20,
                "max": 40,
                "step": null,
                "choices": null,
                "default": 30
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "MOMENTUM_VORTEX_V1",
        "name": "Vortex Indicator",
        "category": "MOMENTUM",
        "description": "Vortex Positive/Negative.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass VortexIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 14) -> pd.DataFrame:\n        vortex = ta.trend.VortexIndicator(df[\"high\"], df[\"low\"], df[\"close\"], window=length)\n        return pd.DataFrame({\n            f\"VI_pos_{length}\": vortex.vortex_indicator_pos(),\n            f\"VI_neg_{length}\": vortex.vortex_indicator_neg(),\n            f\"VI_diff_{length}\": vortex.vortex_indicator_diff()\n        }, index=df.index)\n",
        "handler_func": "VortexIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 5,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 14
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "MOMENTUM_PMO_V1",
        "name": "Price Momentum Oscillator",
        "category": "MOMENTUM",
        "description": "PMO = EMA(EMA(ROC)).",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass PMOIndicator:\n    def compute(self, df: pd.DataFrame, len1: int = 35, len2: int = 20) -> pd.DataFrame:\n        # PMO = EMA(EMA(ROC(1), 35), 20)\n        # Custom Calc\n        roc = df['close'].diff() # 1-period ROC (Price change)\n        # Using EMA of Price Change (Manual)\n        \n        # 1. Custom Smoothing Function\n        def ema(series, span):\n            return series.ewm(span=span, adjust=False).mean()\n        \n        # Note: Standard PMO uses Smoothing Factor = 2/Length... same as standard EMA?\n        # Typically PMO uses Custom Ema: VAL = VALprev + (2/n)*(Price - VALprev)\n        # Yes standard EMA.\n        \n        # ROC is usually (Price - Prev)/Prev * 100 or just Price Change?\n        # PMO uses (Price - PrevPrice) / PrevPrice * 100? No, usually pure Price Change or ROC.\n        # StockCharts definition: ROC = (Price - Price(1)) / Price(1) * 100\n        roc_p = df['close'].pct_change() * 100\n        \n        ema1 = ema(roc_p, len1) # Smoothing 1\n        pmo = ema(ema1, len2)   # Smoothing 2\n        \n        # Signal Line\n        signal = ema(pmo, 10)\n        \n        return pd.DataFrame({\n            f\"PMO_{len1}_{len2}\": pmo,\n            f\"PMO_sig_{len1}_{len2}\": signal\n        }, index=df.index)\n",
        "handler_func": "PMOIndicator",
        "params": [
            {
                "name": "len1",
                "param_type": "int",
                "min": 20,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 35
            },
            {
                "name": "len2",
                "param_type": "int",
                "min": 10,
                "max": 30,
                "step": null,
                "choices": null,
                "default": 20
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "MOMENTUM_EFI_V1",
        "name": "Elders Force Index",
        "category": "MOMENTUM",
        "description": "Force Index.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass EFIIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 13) -> pd.DataFrame:\n        efi = ta.volume.ForceIndexIndicator(df[\"close\"], df[\"volume\"], window=length).force_index()\n        return pd.DataFrame({f\"EFI_{length}\": efi}, index=df.index)\n",
        "handler_func": "EFIIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 5,
                "max": 30,
                "step": null,
                "choices": null,
                "default": 13
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "MOMENTUM_PAM_V1",
        "name": "Price Action Momentum",
        "category": "MOMENTUM",
        "description": "Price Action Momentum (Z-Score from MA).",
        "code_snippet": "\nimport pandas as pd\nimport numpy as np\n\nclass PAMIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 10) -> pd.DataFrame:\n        # Simple Proxy for Price Action Momentum\n        # Normalized Slope of Linear Regression over 'length'\n        \n        # We can use ta's linear regression slope validation\n        # But let's use a simpler \"Velocity\" metric: (Price - MA) / StdDev\n        \n        ma = df['close'].rolling(length).mean()\n        std = df['close'].rolling(length).std()\n        \n        pam = (df['close'] - ma) / (std + 1e-9)\n        \n        return pd.DataFrame({f\"PAM_{length}\": pam}, index=df.index)\n",
        "handler_func": "PAMIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 5,
                "max": 30,
                "step": null,
                "choices": null,
                "default": 10
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLATILITY_UI_V1",
        "name": "Ulcer Index",
        "category": "VOLATILITY",
        "description": "Measures dowside risk.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass UlcerIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 14) -> pd.DataFrame:\n        ui = ta.volatility.UlcerIndex(df[\"close\"], window=length)\n        return pd.DataFrame({f\"UI_{length}\": ui.ulcer_index()}, index=df.index)\n",
        "handler_func": "UlcerIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 5,
                "max": 30,
                "step": null,
                "choices": null,
                "default": 14
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLATILITY_BB_ADV_V1",
        "name": "Bollinger Advanced",
        "category": "VOLATILITY",
        "description": "Bollinger %B and Bandwidth.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass BBAdvIndicator:\n    def compute(self, df: pd.DataFrame, window: int = 20, std_dev: float = 2.0) -> pd.DataFrame:\n        bb = ta.volatility.BollingerBands(df[\"close\"], window=window, window_dev=std_dev)\n        return pd.DataFrame({\n            f\"BB_pct_b_{window}\": bb.bollinger_pband(),\n            f\"BB_width_{window}\": bb.bollinger_wband()\n        }, index=df.index)\n",
        "handler_func": "BBAdvIndicator",
        "params": [
            {
                "name": "window",
                "param_type": "int",
                "min": 10,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 20
            },
            {
                "name": "std_dev",
                "param_type": "float",
                "min": 1.5,
                "max": 3.0,
                "step": null,
                "choices": null,
                "default": 2.0
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLATILITY_CV_V1",
        "name": "Chaikin Volatility",
        "category": "VOLATILITY",
        "description": "ROC of EMA(High-Low).",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass CVIndicator:\n    def compute(self, df: pd.DataFrame, window: int = 10, roc_window: int = 10) -> pd.DataFrame:\n        # Chaikin Volatility: ROC of EMA (High-Low)\n        \n        # 1. HL Range\n        hl = df[\"high\"] - df[\"low\"]\n        \n        # 2. EMA of HL\n        ema_hl = hl.ewm(span=window, adjust=False).mean()\n        \n        # 3. ROC of EMA\n        cv = ema_hl.pct_change(periods=roc_window) * 100\n        \n        return pd.DataFrame({f\"CV_{window}_{roc_window}\": cv}, index=df.index)\n",
        "handler_func": "CVIndicator",
        "params": [
            {
                "name": "window",
                "param_type": "int",
                "min": 5,
                "max": 30,
                "step": null,
                "choices": null,
                "default": 10
            },
            {
                "name": "roc_window",
                "param_type": "int",
                "min": 5,
                "max": 30,
                "step": null,
                "choices": null,
                "default": 10
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLATILITY_RVI_V1",
        "name": "Relative Volatility Index",
        "category": "VOLATILITY",
        "description": "RSI applied to StdDev.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass RVIIndicator:\n    def compute(self, df: pd.DataFrame, height: int = 14, length: int = 14) -> pd.DataFrame:\n        # RVI logic: Similar to RSI but using Stdev instead of Price Change\n        # RVI = 100 * (UpStd / (UpStd + DownStd)) (Smoothed)\n        \n        std = df[\"close\"].rolling(window=10).std() # Base Volatility Proxy\n        \n        # Direction\n        change = df[\"close\"].diff()\n        \n        up = std.where(change > 0, 0)\n        down = std.where(change < 0, 0)\n        \n        # Wilder's Smoothing (EMA with alpha=1/n)\n        up_avg = up.ewm(alpha=1/length, adjust=False).mean()\n        down_avg = down.ewm(alpha=1/length, adjust=False).mean()\n        \n        rvi = 100 * (up_avg / (up_avg + down_avg + 1e-9))\n        \n        return pd.DataFrame({f\"RVI_{length}\": rvi}, index=df.index)\n",
        "handler_func": "RVIIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 10,
                "max": 30,
                "step": null,
                "choices": null,
                "default": 14
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLATILITY_ENV_V1",
        "name": "Moving Average Envelope",
        "category": "VOLATILITY",
        "description": "MA +/- Pct.",
        "code_snippet": "\nimport pandas as pd\n\nclass EnvelopeIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 20, pct: float = 0.05) -> pd.DataFrame:\n        ma = df[\"close\"].rolling(window=length).mean()\n        upper = ma * (1 + pct)\n        lower = ma * (1 - pct)\n        \n        return pd.DataFrame({\n            f\"ENV_up_{length}_{pct}\": upper,\n            f\"ENV_lo_{length}_{pct}\": lower\n        }, index=df.index)\n",
        "handler_func": "EnvelopeIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 10,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 20
            },
            {
                "name": "pct",
                "param_type": "float",
                "min": 0.01,
                "max": 0.1,
                "step": 0.01,
                "choices": null,
                "default": 0.05
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLATILITY_STD_V1",
        "name": "Standard Deviation",
        "category": "VOLATILITY",
        "description": "Rolling Standard Deviation.",
        "code_snippet": "\nimport pandas as pd\n\nclass StdDevIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 20) -> pd.DataFrame:\n        std = df[\"close\"].rolling(window=length).std()\n        return pd.DataFrame({f\"STD_{length}\": std}, index=df.index)\n",
        "handler_func": "StdDevIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 10,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 20
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLATILITY_KALMAN_V1",
        "name": "Kalman Filter",
        "category": "VOLATILITY",
        "description": "1D Kalman Smoother.",
        "code_snippet": "\nimport pandas as pd\nimport numpy as np\n\nclass KalmanFilterIndicator:\n    def compute(self, df: pd.DataFrame, r_ratio: float = 0.1) -> pd.DataFrame:\n        # Simple 1D Kalman Filter for Price Denoising\n        # x_est = x_pred + K * (measured - x_pred)\n        \n        prices = df['close'].values\n        n = len(prices)\n        \n        # State\n        x_est = np.zeros(n)\n        p_est = np.zeros(n) # Covariance\n        \n        # Initialization\n        x_est[0] = prices[0]\n        p_est[0] = 1.0\n        \n        # Parameters\n        Q = 1e-5 # Process Variance (Small -> Smooth)\n        R = r_ratio ** 2 # Measurement Variance\n        \n        for i in range(1, n):\n            # Predict\n            x_pred = x_est[i-1]\n            p_pred = p_est[i-1] + Q\n            \n            # Update\n            K = p_pred / (p_pred + R)\n            x_est[i] = x_pred + K * (prices[i] - x_pred)\n            p_est[i] = (1 - K) * p_pred\n            \n        return pd.DataFrame({\"Kalman\": pd.Series(x_est, index=df.index)}, index=df.index)\n",
        "handler_func": "KalmanFilterIndicator",
        "params": [
            {
                "name": "r_ratio",
                "param_type": "float",
                "min": 0.01,
                "max": 0.5,
                "step": null,
                "choices": null,
                "default": 0.1
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLUME_ADL_V1",
        "name": "Accumulation/Distribution",
        "category": "VOLUME",
        "description": "ADL.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass ADLIndicator:\n    def compute(self, df: pd.DataFrame) -> pd.DataFrame:\n        adl = ta.volume.AccDistIndexIndicator(df[\"high\"], df[\"low\"], df[\"close\"], df[\"volume\"]).acc_dist_index()\n        return pd.DataFrame({\"ADL\": adl}, index=df.index)\n",
        "handler_func": "ADLIndicator",
        "params": [],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLUME_CHO_V1",
        "name": "Chaikin Oscillator",
        "category": "VOLUME",
        "description": "Momentum of ADL.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass ChaikinOscIndicator:\n    def compute(self, df: pd.DataFrame, fast: int = 3, slow: int = 10) -> pd.DataFrame:\n        # Chaikin Oscillator is (Fast EMA of ADL) - (Slow EMA of ADL)\n        # TA Lib has it? Let's check or build manually from ADL\n        adl = ta.volume.AccDistIndexIndicator(df[\"high\"], df[\"low\"], df[\"close\"], df[\"volume\"]).acc_dist_index()\n        ema_f = ta.trend.EMAIndicator(adl, window=fast).ema_indicator()\n        ema_s = ta.trend.EMAIndicator(adl, window=slow).ema_indicator()\n        return pd.DataFrame({f\"ChO_{fast}_{slow}\": ema_f - ema_s}, index=df.index)\n",
        "handler_func": "ChaikinOscIndicator",
        "params": [
            {
                "name": "fast",
                "param_type": "int",
                "min": 2,
                "max": 10,
                "step": null,
                "choices": null,
                "default": 3
            },
            {
                "name": "slow",
                "param_type": "int",
                "min": 10,
                "max": 30,
                "step": null,
                "choices": null,
                "default": 10
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLUME_PVT_V1",
        "name": "Price and Volume Trend",
        "category": "VOLUME",
        "description": "Cumulative Volume * Price Change.",
        "code_snippet": "\nimport pandas as pd\n\nclass PVTIndicator:\n    def compute(self, df: pd.DataFrame) -> pd.DataFrame:\n        # PVT = Cumulative (Volume * (Close - PrevClose) / PrevClose)\n        # PVT = Cumulative (Volume * ROC)\n        \n        roc = df['close'].pct_change()\n        pvt = (roc * df['volume']).cumsum()\n        \n        return pd.DataFrame({\"PVT\": pvt}, index=df.index)\n",
        "handler_func": "PVTIndicator",
        "params": [],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "VOLUME_VROC_V1",
        "name": "Volume ROC",
        "category": "VOLUME",
        "description": "Rate of Change of Volume.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass VROCIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 14) -> pd.DataFrame:\n        # Volume ROC\n        vroc = df['volume'].pct_change(periods=length) * 100\n        return pd.DataFrame({f\"VROC_{length}\": vroc}, index=df.index)\n",
        "handler_func": "VROCIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 5,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 14
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "ADAPTIVE_KAMA_V1",
        "name": "Kaufman Adaptive MA",
        "category": "ADAPTIVE",
        "description": "Adapts to market noise.",
        "code_snippet": "\nimport pandas as pd\nimport ta\n\nclass KAMAIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 10) -> pd.DataFrame:\n        kama = ta.momentum.KAMAIndicator(df[\"close\"], window=length)\n        return pd.DataFrame({f\"KAMA_{length}\": kama.kama()}, index=df.index)\n",
        "handler_func": "KAMAIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 5,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 10
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "ADAPTIVE_RAVI_V1",
        "name": "RAVI",
        "category": "ADAPTIVE",
        "description": "Range Action Verification Index.",
        "code_snippet": "\nimport pandas as pd\nimport numpy as np\n\nclass RAVIIndicator:\n    def compute(self, df: pd.DataFrame, short_len: int = 7, long_len: int = 65) -> pd.DataFrame:\n        # RAVI = Abs(SMA(7) - SMA(65)) / SMA(65) * 100\n        sma_s = df['close'].rolling(window=short_len).mean()\n        sma_l = df['close'].rolling(window=long_len).mean()\n        \n        ravi = np.abs(sma_s - sma_l) / (sma_l + 1e-9) * 100\n        return pd.DataFrame({f\"RAVI_{short_len}_{long_len}\": ravi}, index=df.index)\n",
        "handler_func": "RAVIIndicator",
        "params": [
            {
                "name": "short_len",
                "param_type": "int",
                "min": 5,
                "max": 20,
                "step": null,
                "choices": null,
                "default": 7
            },
            {
                "name": "long_len",
                "param_type": "int",
                "min": 30,
                "max": 100,
                "step": null,
                "choices": null,
                "default": 65
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "ADAPTIVE_KALMAN_V1",
        "name": "Adaptive Kalman Filter",
        "category": "ADAPTIVE",
        "description": "Volatility-Adaptive Kalman.",
        "code_snippet": "\nimport pandas as pd\nimport numpy as np\n\nclass AdaptiveKalmanIndicator:\n    def compute(self, df: pd.DataFrame, q: float = 1e-5, r: float = 0.01) -> pd.DataFrame:\n        # Adaptive Kalman: Adjusts R based on recent volatility\n        prices = df['close'].values\n        n = len(prices)\n        x_est = np.zeros(n)\n        p_est = np.zeros(n)\n        \n        x_est[0] = prices[0]\n        p_est[0] = 1.0\n        \n        # Calculate Rolling Volatility for Adaptive R\n        # (Simplified pre-calculation for vector speed)\n        vol = df['close'].pct_change().rolling(20).std().fillna(0.01).values\n        \n        for i in range(1, n):\n            # Adapt R based on volatility\n            # Higher Vol => Higher Uncertainty => Higher R => Slower update\n            current_r = r * (1 + (vol[i] * 100))\n            \n            # Predict\n            x_pred = x_est[i-1]\n            p_pred = p_est[i-1] + q\n            \n            # Update\n            K = p_pred / (p_pred + current_r)\n            x_est[i] = x_pred + K * (prices[i] - x_pred)\n            p_est[i] = (1 - K) * p_pred\n            \n        return pd.DataFrame({\"Adapt_Kalman\": x_est}, index=df.index)\n",
        "handler_func": "AdaptiveKalmanIndicator",
        "params": [
            {
                "name": "r",
                "param_type": "float",
                "min": 0.001,
                "max": 0.1,
                "step": null,
                "choices": null,
                "default": 0.01
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "ADAPTIVE_POLARITY_V1",
        "name": "Polarity Switcher",
        "category": "ADAPTIVE",
        "description": "Trend Polarity with Volume.",
        "code_snippet": "\nimport pandas as pd\nimport numpy as np\n\nclass PolarityIndicator:\n    def compute(self, df: pd.DataFrame, length: int = 20) -> pd.DataFrame:\n        # Detects Regime Switch Polarity\n        # Score +1 (Bull) to -1 (Bear)\n        # Based on Price vs EMA and Volume flow\n        \n        ema = df['close'].ewm(span=length).mean()\n        diff = (df['close'] - ema) / (ema + 1e-9)\n        \n        # Volume conformation\n        vol_ma = df['volume'].rolling(length).mean()\n        vol_ratio = df['volume'] / (vol_ma + 1e-9)\n        \n        # Polarity signal: diff * vol_ratio (Amplify move if high volume)\n        polarity = diff * vol_ratio\n        \n        # Smooth it\n        polarity_smooth = polarity.rolling(5).mean()\n        \n        return pd.DataFrame({f\"Polarity_{length}\": polarity_smooth}, index=df.index)\n",
        "handler_func": "PolarityIndicator",
        "params": [
            {
                "name": "length",
                "param_type": "int",
                "min": 10,
                "max": 50,
                "step": null,
                "choices": null,
                "default": 20
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "PA_PIVOT_V1",
        "name": "Pivot Points",
        "category": "PRICE_ACTION",
        "description": "Rolling Pivot Points.",
        "code_snippet": "\nimport pandas as pd\n\nclass PivotPointsIndicator:\n    def compute(self, df: pd.DataFrame, window: int = 20) -> pd.DataFrame:\n        # Rolling Standard Pivot Points\n        # Using a window to simulate \"Previous Period\" (e.g., last 20 days as 'last month')\n        \n        high = df['high'].rolling(window=window).max()\n        low = df['low'].rolling(window=window).min()\n        close = df['close'] # Current close? No, Pivot uses PREVIOUS period close.\n        # So shift everything by 1\n        \n        pp_high = high.shift(1)\n        pp_low = low.shift(1)\n        pp_close = df['close'].shift(window).fillna(method='bfill') # Approximate previous 'session' close via lag\n        \n        # PP = (H + L + C) / 3\n        pp = (pp_high + pp_low + pp_close) / 3\n        r1 = (2 * pp) - pp_low\n        s1 = (2 * pp) - pp_high\n        \n        # Return distance to Pivot\n        dist_pp = (df['close'] - pp) / pp * 100\n        \n        return pd.DataFrame({\n            f\"Pivot_Level_{window}\": pp,\n            f\"Dist_to_PP_{window}\": dist_pp,\n            f\"R1_{window}\": r1,\n            f\"S1_{window}\": s1\n        }, index=df.index)\n",
        "handler_func": "PivotPointsIndicator",
        "params": [
            {
                "name": "window",
                "param_type": "int",
                "min": 5,
                "max": 60,
                "step": null,
                "choices": null,
                "default": 20
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "PA_FIBO_V1",
        "name": "Fibonacci Retracement",
        "category": "PRICE_ACTION",
        "description": "Position in HL Range.",
        "code_snippet": "\nimport pandas as pd\n\nclass FiboIndicator:\n    def compute(self, df: pd.DataFrame, window: int = 50) -> pd.DataFrame:\n        # Dynamic Fibonacci Retracement within window\n        # 0% = Low, 100% = High\n        \n        period_high = df['high'].rolling(window=window).max()\n        period_low = df['low'].rolling(window=window).min()\n        range_hl = period_high - period_low + 1e-9\n        \n        # Current Position in Range (0.0 to 1.0)\n        pos = (df['close'] - period_low) / range_hl\n        \n        # Key Levels: 0.236, 0.382, 0.5, 0.618\n        # Return distance to nearest major fib level (0.5 or 0.618)\n        \n        dist_618 = pos - 0.618\n        \n        return pd.DataFrame({\n            f\"Fibo_Pos_{window}\": pos,\n            f\"Dist_Fib618_{window}\": dist_618\n        }, index=df.index)\n",
        "handler_func": "FiboIndicator",
        "params": [
            {
                "name": "window",
                "param_type": "int",
                "min": 20,
                "max": 200,
                "step": null,
                "choices": null,
                "default": 50
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "PA_SR_V1",
        "name": "S&R Levels",
        "category": "PRICE_ACTION",
        "description": "Distance to Rolling High/Low.",
        "code_snippet": "\nimport pandas as pd\nimport numpy as np\n\nclass SRLevelIndicator:\n    def compute(self, df: pd.DataFrame, window: int = 20) -> pd.DataFrame:\n        # Rolling Max/Min as proxies for S/R\n        # Resistance\n        res_level = df['high'].rolling(window=window).max().shift(1)\n        # Support\n        sup_level = df['low'].rolling(window=window).min().shift(1)\n        \n        # Distance %\n        dist_res = (res_level - df['close']) / df['close'] * 100\n        dist_sup = (df['close'] - sup_level) / df['close'] * 100\n        \n        return pd.DataFrame({\n            f\"Dist_Res_{window}\": dist_res,\n            f\"Dist_Sup_{window}\": dist_sup\n        }, index=df.index)\n",
        "handler_func": "SRLevelIndicator",
        "params": [
            {
                "name": "window",
                "param_type": "int",
                "min": 10,
                "max": 100,
                "step": null,
                "choices": null,
                "default": 20
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "PA_VP_V1",
        "name": "Volume Profile Proxy",
        "category": "PRICE_ACTION",
        "description": "VWAP Distance & Vol Intensity.",
        "code_snippet": "\nimport pandas as pd\nimport numpy as np\n\nclass VPIndicator:\n    def compute(self, df: pd.DataFrame, window: int = 50, bins: int = 10) -> pd.DataFrame:\n        # Approximating Volume Profile features\n        # We calculate VWAP of the window as the POC (Point of Control) proxy\n        # And check if current price is in valid \"Value Area\"\n        \n        # Rolling VWAP\n        cv = (df['close'] * df['volume']).rolling(window).sum()\n        v_sum = df['volume'].rolling(window).sum()\n        vwap = cv / (v_sum + 1e-9)\n        \n        # Distance to VWAP (Proxy for HVN/POC)\n        dist_vwap = (df['close'] - vwap) / vwap * 100\n        \n        # Volume Intensity (Current Vol / Avg Vol)\n        vol_intensity = df['volume'] / df['volume'].rolling(window).mean()\n        \n        # Logic: If price is near VWAP and Volume is High -> HVN interaction\n        \n        return pd.DataFrame({\n            f\"Dist_POC_{window}\": dist_vwap,\n            f\"Vol_Intensity_{window}\": vol_intensity\n        }, index=df.index)\n",
        "handler_func": "VPIndicator",
        "params": [
            {
                "name": "window",
                "param_type": "int",
                "min": 20,
                "max": 100,
                "step": null,
                "choices": null,
                "default": 50
            }
        ],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    },
    {
        "feature_id": "PATTERN_HEIKIN_V1",
        "name": "Heikin Ashi",
        "category": "PATTERN",
        "description": "Heikin Ashi Smoothed Close.",
        "code_snippet": "\nimport pandas as pd\n\nclass HeikinAshiIndicator:\n    def compute(self, df: pd.DataFrame) -> pd.DataFrame:\n        ha_close = (df['open'] + df['high'] + df['low'] + df['close']) / 4\n        \n        # HA Open needs recursive calculation\n        ha_open = [df['open'].iloc[0]]\n        for i in range(1, len(df)):\n            ha_open.append((ha_open[-1] + df['open'].iloc[i]) / 2) # Approximation for vector speed? No, standard is (prevent_ha_open + prev_ha_close)\n        \n        # Proper HA Open: (Prev HA Open + Prev HA Close) / 2\n        # Let's do loop\n        ha_o = []\n        prev_o = df['open'].iloc[0]\n        prev_c = df['close'].iloc[0]\n        \n        for i in range(len(df)):\n            if i == 0:\n                curr_o = (prev_o + prev_c) / 2\n            else:\n                curr_o = (ha_o[-1] + ha_c[i-1]) / 2 # Need ha_c generated first?\n            \n            # Actually standard:\n            # HA_Close = (O+H+L+C)/4\n            # HA_Open = (Prev_HA_Open + Prev_HA_Close) / 2\n            # HA_High = Max(H, HA_O, HA_C)\n            # HA_Low = Min(L, HA_O, HA_C)\n            pass\n            \n        # Simplified Return: HA Close\n        return pd.DataFrame({\"HA_Close\": ha_close}, index=df.index)\n",
        "handler_func": "HeikinAshiIndicator",
        "params": [],
        "complexity_score": 1.0,
        "source": "builtin",
        "tags": [],
        "fitness_score": 0.0,
        "usage_count": 0
    }
]